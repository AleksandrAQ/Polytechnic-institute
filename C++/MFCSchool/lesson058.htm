<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0050)lesson058.htm -->
<HTML><HEAD><TITLE>Програмирование на Visual C++</TITLE>
</HEAD>
<BODY background="../bgrwhite.gif">
      <CENTER><B>Урок VIII</B></CENTER></FONT>
      <P>
      <P align=center><FONT color=black face=ARIAL size=4>Проектирование 
      диалоговой панели</FONT></P>
      <p>Учения-Мучения! 
            <UL type=square>
              <LI>Сейчас нам необходимо добавить код выбора фигур для рисования! 

              <LI>У нас будет три фигуры (прямоугольник, овал, линия) и 
              свободное рисование, по умолчанию будет устанавливаться свободное 
              рисование (FREEHAND). 
              <LI>Мы будем выбирать эти формы из списка, для этого нам 
              понадобится элемент управления <B>Combo Box</B>, который будет 
              содержать список фигур для рисования, добавьте элемент управления 
              согласно рисунку 2, и таблице 2. 
              <LI>Элементы этого списка, мы должны будем указать прямо в 
              свойствах элемента на странице <B>Data</B>, чтобы ввести название 
              следующего элемента, для этого надо нажать не <B>Enter</B>, а 
              <B>Ctrl+Enter</B>. </LI></UL>
            <UL type=square>
              <P align=center><IMG 
              src="lesson058.files/vc_resource_dlg_proekt6.gif"></P>
              <P align=center><FONT color=red><B>Таблица 2.0</B></FONT></P>
              <DIV align=center>
              <TABLE bgColor=#ffffbb border=1 cellPadding=0 cellSpacing=0 
              width="80%">
                <TBODY>
                <TR>
                  <TD><FONT face=ARIAL size=2><B>Объект</B></FONT></TD>
                  <TD><FONT face=ARIAL size=2><B>Свойство</B></FONT></TD>
                  <TD><FONT face=ARIAL size=2><B>Установка</B></FONT></TD></TR>
                <TR>
                  <TD colSpan=3>&nbsp;</TD></TR>
                <TR>
                  <TD><FONT face=ARIAL size=2><B>Combo Box</B></FONT></TD>
                  <TD><FONT face=ARIAL size=2><B>ID</B></FONT></TD>
                  <TD><FONT face=ARIAL size=2><B>IDC_SHAPES</B></FONT></TD></TR>
                <TR>
                  <TD></TD>
                  <TD><FONT face=ARIAL size=2>Type</FONT></TD>
                  <TD><FONT face=ARIAL size=2>Drop List</FONT></TD></TR>
                <TR>
                  <TD></TD>
                  <TD><FONT face=ARIAL size=2>Элемент1</FONT></TD>
                  <TD><FONT face=ARIAL size=2>FreeHand, страница 
                Data</FONT></TD></TR>
                <TR>
                  <TD></TD>
                  <TD><FONT face=ARIAL size=2>Элемент2</FONT></TD>
                  <TD><FONT face=ARIAL size=2>Lines, страница 
Data</FONT></TD></TR>
                <TR>
                  <TD></TD>
                  <TD><FONT face=ARIAL size=2>Элемент3</FONT></TD>
                  <TD><FONT face=ARIAL size=2>Ovals, страница 
Data</FONT></TD></TR>
                <TR>
                  <TD></TD>
                  <TD><FONT face=ARIAL size=2>Элемент4</FONT></TD>
                  <TD><FONT face=ARIAL size=2>Rectangle, страница 
                  Data</FONT></TD></TR>
                <TR>
                  <TD><FONT face=ARIAL size=2><B>Group Box</B></FONT></TD>
                  <TD><FONT face=ARIAL size=2><B>ID<B></FONT></B></B></TD>
                  <TD><FONT face=ARIAL size=2><B>IDC_STATIC</B></FONT></TD></TR>
                <TR>
                  <TD></TD>
                  <TD><FONT face=ARIAL size=2>Caption</FONT></TD>
                  <TD><FONT face=ARIAL size=2>&amp;Lines and 
                Shapes</FONT></TD></TR></TR></TBODY></TABLE></DIV>
              <P><BR>
              <P>
              <LI>Тип элемента указывает на то, что значения будут постоянными и 
              их нельзя менять, т.е. просто список названий. 
              <LI>Затем вы добавляете элементы списка, не забывая, что чтобы 
              добавить следующий элемент, необходимо нажать <B>Ctrl+Enter</B>. 
              <LI>Теперь нам необходимо связать этот элемент управления с 
              переменной, с помощью которой мы будем получать значение позиции 
              выбранного названия фигуры. Потом мы добавим хитренький код, 
              который будет реализировать рисование фигур. 
              <P></P></LI></UL>
            <UL type=square>
              <LI>Сечас откройте <B>Class Wizard</B>, а там закладку <B>Member 
              Variables</B>. 
              <LI>Отметьте мышкой индетификатор <B>IDC_SHAPES</B> и нажмите на 
              кнопку <B>Add Variable</B> 
              <LI>Введите название переменной <B>m_ShapesCombo</B>, 
              <B>Category</B> - <B>Control</B>, <B>Variable Type</B> - 
              <B>CComboBox</B>. 
              <LI>Нажмите <B>OK</B>. 
              <LI>Закройте ClassWizard. 
              <LI>Откройте функцию <B>OnInitDialog</B> и в конец(перед 
              оператором return) добавьте следующий код: <BR>
              <P><B>////-Ваш код начинается здесь -////
              <P>//Установить начальную позицию 
              курсора<BR>m_ShapesCombo.SetCurSel(0);
              <P>////-Ваш код заканчивается здесь -////
              <P></B></P>
              <LI>Этим оператором вы устанавливаете начальную позицию курсора, 
              на первой строчке. 
              <LI>Теперь пришло время разобраться в теории, для рисования линий 
              и фигур нам необходимо применять метод резиновой нити, т.е. когда 
              вы нажали на мышки и хотите нарисовать фигуру, вы же вначале 
              подбираете ее размер, т.е. при выборе размера, вы тоже рисуете, но 
              при каждом движении мыши предыдущий объект должен стираться до тех 
              пор пока, не будет отпущена мышка, когда это произойдет, надо 
              будет нарисовать окончательный объект. Так вот метод резиновой 
              нити рисует фигуру, с инвертированием цветов под ним, т.е. мы 
              можем различать, когда мы выбираем размеры и когда уже 
              оканчательно нарисовано. Вся изюменка этого метода в том, что при 
              повторном рисовании фигуры, предыдущая стирается, а когда кнопку 
              мышки отпускаете, то рисуется все окончательно без всяких 
              приколов. 
              <LI>Теперь расскажу, как все организовать. Вначале мы добавим 
              переменную <B>m_IsDrawing</B> типа <B>bool</B>, которая будет 
              принимать два значения <B>false</B> и <B>true</B>, эта переменная 
              будет отвечать за,то чтобы рисовать при движении мыши или нет. 
              <LI>Необходимо будет написать саму функцию рисования фигур, в 
              которой и будет релиазоваться метод резиновой нити и само 
              рисование, она будет использовать переменную <B>stretch</B> для 
              определения метода рисования. 
              <LI>Затем нужно будет изменить немного все функции связанные с 
              событиями мыши. 
              <LI>Ну что, начнем. 
              <P><FONT color=red size=3><B>Добавление функции 
              DrawShape</B></FONT></P>
              <P></P>
              <LI>C помощью <B>WorkSpace</B> добавьте функцию с 
              названием<BR><B>DrawShape(bool stretch=false)</B>, с типом 
              <B>void</B> и доступом <B>Private</B>. Откроем ее в окне 
              редактирования. И напишем следующий код, в котором скоро 
              разберемся: <B>
              <P>void CPaintORamaDlg::DrawShape(bool stretch)<BR>{<BR>//Получить 
              объект контекста устройства<BR>CClientDC dc(this);
              <P>//Установить атрибуты 
              DC<BR>dc.SetAttribDC(dc);<BR>dc.IntersectClipRect(m_Canvas);
              <P>//Получить номер позиции из спика названий фигур<BR>int 
              drawmode=m_ShapesCombo.GetCurSel();
              <P>//Выбрать перо<BR>dc.SelectObject(&amp;m_Pen);
              <P>//Метод резиновой нити<BR>if(stretch &amp;&amp; 
              drawmode!=0)<BR>{<BR>//Установить метод резиновой 
              нити<BR>dc.SetROP2(R2_NOT);<BR>}
              <P>//Конструкция выбора 
              фигуры<BR>switch(drawmode)<BR>{<BR>//Свободное рисование<BR>case 
              0:<BR>dc.MoveTo(m_LineStart);<BR>dc.LineTo(m_LineEnd);<BR>m_LineStart=m_LineEnd;<BR>break;<BR>
              <P>//Рисование линий<BR>case 
              1:<BR>dc.MoveTo(m_LineStart);<BR>dc.LineTo(m_LineEnd);<BR>break;<BR>
              <P>//Рисование элипсов<BR>case 
              2:<BR>dc.Ellipse(CRect(m_LineStart,m_LineEnd));<BR>break;<BR>
              <P>//Рисование прямоугольника<BR>case 
              3:<BR>dc.Rectangle(CRect(m_LineStart,m_LineEnd));<BR>break;<BR>}<BR><BR>}<BR></B></P>
              <LI>Вначале по стандарту получаем объект контекста устройства, 
              потом устанавливаем атрибуты <B>DC</B>. Считываем номер выбранного 
              элемента в списке фигур и записываем его в переменную 
              <B>drawmode</B>. 
              <LI>Переменная <B>stretch</B> отвечает за то, чтобы применять 
              метод резиновой нити или нет, так например, для рисования в 
              свободной форме(точка за точкой) не нужно удалять предыдущее 
              состояние, или когда отпускаете кнопку мыши, тоже не надо 
              применять метод РН. 
              <LI>Конструкция оператора <B>IF</B> проверяет, что если режим 
              рисования и номер выбранной фигуры не равны 0, то применить метод 
              резиновой нити, т.е. если не выбрано свободное рисование и мы 
              находитесь в стадии выбора размера фигуры, то применить метод 
              резиновой нити. 
              <LI>Потом конструкция оператора <B>switch</B> реализует выбор 
              фигуры и ее рисование. Например, если вы выбрали фигуру овал, то 
              <B>drawmode</B> будет равен 2, т.е. оператор <B>switch</B> найдет 
              метку 2 и нарисует элипс, заданный координатами прямоугольника 
              класса <B>CRect</B>, вы, наверное, заметили, что координаты заданы 
              двумя переменными и они инициализируют объект класса, который в 
              свою очередь возращает значение всех четырех координат. 
              <LI>Оператор <B>break</B> выходит из конструкции оператора 
              <B>switch</B>, после того, как что-нибудь будет нарисовано. 
              <LI>И еще заметьте, что предыдущие координаты для свободного 
              рисования изменяются сразу.
              <P></P>
              <LI>Теперь надо, изменить все функции обработки сообщений мыши. 
              <LI>Измените функцию <B>OnLButtonDown</B> следующим образом: 
              <P><B>BOOL CPaintORamaDlg::OnLButtonDown(UINT nFlags, CPoint 
              point) <BR>{<BR><BR>.....<BR>
              <P>//Проверить было ли нажатие внутри области 
              рисования.<BR>if(m_Canvas.PtInRect(point))<BR>{<BR>//Присвоить 
              координаты начала двум переменным<BR>m_LineStart= 
              point;<BR>m_LineEnd=point;
              <P>/////-Ваш код начинается здесь-///
              <P><FONT color=red>m_IsDrawing=true;</FONT>
              <P>/////-Ваш код заканчивается здесь-/////
              <P>m_Pen.DeleteObject();
              <P>//Обновить переменные значениями в окне 
              прграммы<BR>UpdateData(TRUE);
              <P>//Создать новую кисть с учетом 
              размера<BR>m_Pen.CreatePen(PS_SOLID, m_PenWidth, m_PenColor);
              <P>//Захватить мышь<BR>SetCapture();<BR>}
              <P>}<BR></B></P>
              <LI>Добавленый оператор присваивает значение <B>true</B> 
              переменной <B>m_IsDrawing</B>, т.е. включается режим рисования, 
              при отпускании кнопки мыши он будет равен <B>false</B>, т.е. 
              отключен. 
              <LI>Теперь нужно в корни изменить код функции <B>OnMouseMove</B>, 
              удалите весь код внутри оператора <B>IF</B>, т.к. он содержит код 
              рисования, а он нам не нужен так, как он будет реализован в 
              функции <B>DrawShape</B>. 
              <LI>Функция <B>OnMouseMove</B> будет выполнять роль рисования 
              методом резиновой нити, т.к. пока вы двигаете мышкой, то вы 
              изменяете размеры фигуры, значит предыдущию фигуру надо стереть, 
              обновить координаты конца, и опять нарисовать. А окончательно 
              фигура нарисуется только в том случае, если вы отпускаете кнопку 
              мыши. 
              <LI>Откройте функцию <B>OnMouseMove</B>, модифицируйте ее 
              следующим образом:
              <P><B>void CPaintORamaDlg::OnMouseMove(UINT nFlags, CPoint 
              point)<BR>{
              <P>////-Мой код начинается здесь-///
              <P>if(<FONT color=red>m_IsDrawing</FONT>&amp;&amp; (nFlags &amp; 
              MK_LBUTTON) &amp;&amp; m_Canvas.PtInRect(point))<BR>{
              <P>//Нарисовать фигуру методом резиновой нити<BR>DrawShape(true);
              <P>/*Поменять координаты конца на текущее положение 
              курсора<BR>m_LineStart=m_LineEnd;
              <P>//Стереть предыдущую и нарисовать новую 
              фигуру<BR>DrawShape(true);
              <P>////-Мой код заканчивается здесь-///
              <P>}
              <P>} </B></P>
              <LI>Вначале вы рисуете фигуру методом резиновой нити, передавая 
              для этого значение аргумента функции <B>true</B>. 
              <LI>Потом меняете координаты конца на текущее положение курсора, а 
              повтором первого оператора, вы удаляете предыдущую фигуру 
              нарисованную методом резиновой нити и рисуете новую. 
              <LI>Вот такой несложный код. 
              <LI>Теперь осталось только изменить код функции 
              <B>OnLButtonUp</B>. 
              <LI>Нам необходимо, проверить была ли отпущена кнопка, внутри окна 
              рисования, если да то нарисовать фигуру уже окончательно, а если 
              нет то стереть предыдущюю фигуру, т.к. когда вы за областью окна 
              рисования отпускаете мышку, то фигура нарисованная методом 
              резиновой нити не зарисовывается окончательной, а остается. 
              <LI>Добавьте следующий код в функцию <B>OnLButtonUp</B>: 
              <P><B>void CPaintORamaDlg::OnLButtonUp(UINT nFlags, CPoint point) 
              <BR>{
              <P>////-Ваш код начинается здесь-////
              <P>//Отключить режим рисования<BR>m_IsDrawing=FALSE;
              <P>/*Если мышка отпущена внутри области рисования, то нарисовать 
              фигуру 
              окончательно*/<BR>if(m_Canvas.PtInRect(point))<BR>{<BR>m_LineEnd=point;<BR>DrawShape();<BR>}<BR>//Если 
              нет, то 
              стереть<BR>else<BR>{<BR>DrawShape(true);<BR>}<BR>m_LineStart=point;
              <P>//Отпустить мышь<BR>ReleaseCapture();
              <P>////-Ваш код заканчивается здесь-////
              <P><BR>}
              <P></B></P>
              <LI>Оператор присваивания отключает режим рисования. 
              <LI>Оператором <B>IF</B> вы проверяете была ли отпущена кнопка 
              внутри области рисования, 
              <LI>Если да, то рисуете окончательную фигуру, закрашивая фигуру 
              нарисованную методом резиновай нити. 
              <LI>Если нет, то стираете предыдущую фигуру, нарисованную методом 
              резиновай нити. 
              <LI>Вот и все с рисованием фигур, но нам еще предстоит, добавить 
              код выбора стиля закраски фигур и цвет самой закраски. Запустите 
              программу и попробуйте выбирать любую фигуру и нарисовать 
              что-нибудь. 
              <P></P></LI></UL><BR><BR>Добавим возможность выбора стиля и цвета 
            заливки.<BR>
            <CENTER><A 
            href="lesson048.htm"><B 
            class=base2>&lt;-Назад</B></A> || <A 
            href="lesson068.htm"><B 
            class=base2>Дальше -&gt;</B></A>
            <P></CENTER>
            <P>
            <CENTER><B><FONT color=green><A 
            href="lesson008.htm">[1]</A><A 
            href="lesson018.htm"> [2]</A> 
            <A 
            href="lesson028.htm">[3]</A><A 
            href="lesson038.htm"> [4]</A><A 
            href="lesson048.htm"> [5] 
            </A>[6]<A href="lesson068.htm"> 
            [7]<A> <A 
            href="lesson078.htm">[8]</A> <A 
            href="lesson088.htm">[9]</A></B></FONT></CENTER></FONT></FONT>
<p><div align="center"><a href="lesson.htm"><img src="../soder.gif" width=120 height=31 border=0 alt=""></a></div></p>		
</BODY></HTML>
